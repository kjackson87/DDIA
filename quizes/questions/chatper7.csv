"What are the four key properties of transactions represented by the ACID acronym?";"<p>The four key properties of transactions represented by the ACID acronym are:</p><ul><li>Atomicity</li><li>Consistency</li><li>Isolation</li><li>Durability</li></ul><p><i>(Reference: The Meaning of ACID, p. 223)</i></p>"
"What does atomicity mean in the context of ACID transactions?";"<p>Atomicity in the context of ACID transactions means:</p><ul><li>If a transaction fails, all of its operations are undone</li><li>The database is left in the state it was before the transaction started</li></ul><p><i>(Reference: Atomicity, p. 223-224)</i></p>"
"Compare and contrast read committed isolation and snapshot isolation. How do they prevent different types of concurrency problems?";"<p>Read committed isolation:</p><ul><li>Prevents dirty reads by only showing committed data</li><li>Does not prevent nonrepeatable reads</li></ul><p>Snapshot isolation:</p><ul><li>Provides a consistent snapshot of the database at the start of the transaction</li><li>Prevents both dirty reads and nonrepeatable reads</li></ul><p><i>(Reference: No dirty reads, p. 234-235; Snapshot Isolation and Repeatable Read, p. 237-238)</i></p>"
"What is the lost update problem and how can it be prevented?";"<p>The lost update problem:</p><ul><li>Occurs when two transactions read and update the same object concurrently, potentially overwriting each other's changes</li><li>Can be prevented using atomic write operations, explicit locking, or automatic detection in some isolation levels</li></ul><p><i>(Reference: Preventing Lost Updates, p. 242-243)</i></p>"
"What is write skew and why is it problematic? How does it relate to the phantom problem?";"<p>Write skew:</p><ul><li>Is a concurrency anomaly where two transactions read overlapping data and make decisions based on that data, but then update different objects</li><li>Can lead to violation of application constraints</li><li>Is related to the phantom problem, where a write in one transaction changes the result of a search query in another transaction</li></ul><p><i>(Reference: Write Skew and Phantoms, p. 246-247; Phantoms causing write skew, p. 250-251)</i></p>"
"What are the three main techniques for implementing serializability, and how do they differ in their approach to concurrency control?";"<p>The three main techniques for implementing serializability are:</p><ol><li>Actual serial execution (pessimistic)</li><li>Two-phase locking (2PL) (pessimistic)</li><li>Serializable snapshot isolation (SSI) (optimistic)</li></ol><p>Pessimistic approaches assume conflicts are likely and prevent them, while optimistic approaches assume conflicts are rare and check for them at commit time.</p><p><i>(Reference: Serializability, p. 251-252; Pessimistic versus optimistic concurrency control, p. 261-262)</i></p>"
"How does actual serial execution achieve serializability, and how can it be optimized for partitioned data?";"<p>Actual serial execution achieves serializability by:</p><ul><li>Executing only one transaction at a time, in serial order, on a single thread</li><li>Completely avoiding concurrency issues</li></ul><p>It can be optimized for partitioned data by:</p><ul><li>Allowing each partition to have its own transaction processing thread</li><li>Enabling linear scalability with CPU cores for single-partition transactions</li></ul><p><i>(Reference: Actual Serial Execution, p. 252-253; Partitioning, p. 255-256)</i></p>"
"Explain how two-phase locking (2PL) works. What types of locks does it use, and what are its main drawbacks?";"<p>Two-phase locking (2PL) works by:</p><ul><li>Acquiring locks before reading or writing data</li><li>Using shared locks for reads and exclusive locks for writes</li><li>Holding all locks until the transaction commits or aborts</li></ul><p>Main drawbacks:</p><ul><li>Significant performance and deadlock issues</li><li>Unstable latencies and very slow performance at high percentiles when there is contention</li></ul><p><i>(Reference: Implementation of two-phase locking, p. 257-258; Performance of two-phase locking, p. 258-259)</i></p>"
"What is predicate locking, and why is it typically approximated with index-range locking in practice?";"<p>Predicate locking:</p><ul><li>Locks all data matching certain search conditions</li><li>Prevents phantoms by locking data that doesn't yet exist</li></ul><p>Index-range locking:</p><ul><li>Approximates predicate locking for better performance</li><li>Locks a wider range of objects than strictly necessary</li><li>Used in practice because true predicate locking is expensive to implement</li></ul><p><i>(Reference: Predicate locks, p. 259-260; Index-range locks, p. 260-261)</i></p>"
"How does serializable snapshot isolation (SSI) detect and prevent serialization conflicts? What are its performance trade-offs compared to other techniques?";"<p>SSI detects serialization conflicts by:</p><ul><li>Tracking reads and writes of transactions</li><li>Detecting when a transaction has read data that was subsequently modified</li><li>Aborting transactions that may have acted on outdated information</li></ul><p>Performance trade-offs:</p><ul><li>Generally better performance than two-phase locking</li><li>Allows long-running reads without blocking writes</li><li>May have higher abort rates in high-contention scenarios</li></ul><p><i>(Reference: Serializable Snapshot Isolation (SSI), p. 261-262; Detecting stale MVCC reads, p. 263-264; Performance of serializable snapshot isolation, p. 265)</i></p>"