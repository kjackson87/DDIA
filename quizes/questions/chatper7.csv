"What are the four key properties of transactions represented by the ACID acronym?";"<p>ACID properties:</p><ul><li><b>A</b>tomicity: All-or-nothing transaction execution</li><li><b>C</b>onsistency: Database remains valid after transaction</li><li><b>I</b>solation: Transactions don't interfere with each other</li><li><b>D</b>urability: Committed changes are permanent</li></ul><p>Example: Bank transfer</p><ul><li>A: Transfer fully completes or fails</li><li>C: Total money remains the same</li><li>I: Other transactions can't see money in transit</li><li>D: Completed transfer persists after system crash</li></ul><p><i>(Reference: The Meaning of ACID, p. 223)</i></p>"
"What does atomicity mean in the context of ACID transactions?";"<p>Atomicity in ACID transactions:</p><ul><li>All operations succeed or all fail</li><li>Database returns to initial state if transaction fails</li></ul><p>Example: $100 transfer from A to B</p><ul><li>If B credit fails, A debit is undone</li><li>A's balance restored, $100 not lost</li></ul><p><i>(Reference: Atomicity, p. 223-224)</i></p>"
"Compare and contrast read committed isolation and snapshot isolation. How do they prevent different types of concurrency problems?";"<p>Read committed:</p><ul><li>Prevents dirty reads</li><li>Allows nonrepeatable reads</li></ul><p>Snapshot isolation:</p><ul><li>Prevents dirty reads</li><li>Prevents nonrepeatable reads</li></ul><p>Example: Balance read twice</p><ul><li>Read committed: May see different values</li><li>Snapshot: Always sees initial value</li></ul><p><i>(Reference: No dirty reads, p. 234-235; Snapshot Isolation and Repeatable Read, p. 237-238)</i></p>"
"What is the lost update problem and how can it be prevented?";"<p>Lost update problem:</p><ul><li>Concurrent read-modify-write cycles overwrite changes</li></ul><p>Prevention:</p><ul><li>Atomic operations</li><li>Explicit locking</li><li>Automatic detection in some isolation levels</li></ul><p>Example: Counter increment</p><ul><li>Problem: Two users read 5, both write 6</li><li>Solution: ""UPDATE counter SET value = value + 1""</li></ul><p><i>(Reference: Preventing Lost Updates, p. 242-243)</i></p>"
"What is write skew and why is it problematic? How does it relate to the phantom problem?";"<p>Write skew:</p><ul><li>Transactions read overlapping data, update different objects</li><li>Can violate application constraints</li></ul><p>Relation to phantom problem:</p><ul><li>Write in one transaction affects another's search results</li></ul><p>Example: Hospital on-call system</p><ul><li>Two doctors take themselves off-call concurrently</li><li>Result: No doctors on-call (constraint violated)</li></ul><p><i>(Reference: Write Skew and Phantoms, p. 246-247; Phantoms causing write skew, p. 250-251)</i></p>"
"What are the three main techniques for implementing serializability, and how do they differ in their approach to concurrency control?";"<p>Serializability techniques:</p><ol><li>Actual serial execution (pessimistic)</li><li>Two-phase locking (2PL) (pessimistic)</li><li>Serializable snapshot isolation (SSI) (optimistic)</li></ol><p>Differences:</p><ul><li>Pessimistic: Prevent conflicts</li><li>Optimistic: Detect conflicts at commit time</li></ul><p><i>(Reference: Serializability, p. 251-252; Pessimistic versus optimistic concurrency control, p. 261-262)</i></p>"
"How does actual serial execution achieve serializability, and how can it be optimized for partitioned data?";"<p>Actual serial execution:</p><ul><li>One transaction at a time, single thread</li><li>Avoids concurrency issues</li></ul><p>Optimization for partitioned data:</p><ul><li>Each partition has own processing thread</li><li>Enables scalability across CPU cores</li></ul><p><i>(Reference: Actual Serial Execution, p. 252-253; Partitioning, p. 255-256)</i></p>"
"Explain how two-phase locking (2PL) works. What types of locks does it use, and what are its main drawbacks?";"<p>Two-phase locking (2PL):</p><ul><li>Acquire locks before data access</li><li>Shared locks for reads, exclusive for writes</li><li>Hold all locks until commit/abort</li></ul><p>Drawbacks:</p><ul><li>Performance issues and deadlocks</li><li>Unstable latencies under contention</li></ul><p>Example: Deadlock</p><ul><li>T1: Lock A, wait for B</li><li>T2: Lock B, wait for A</li></ul><p><i>(Reference: Implementation of two-phase locking, p. 257-258; Performance of two-phase locking, p. 258-259)</i></p>"
"What is predicate locking, and why is it typically approximated with index-range locking in practice?";"<p>Predicate locking:</p><ul><li>Locks data matching search conditions</li><li>Prevents phantoms</li></ul><p>Index-range locking:</p><ul><li>Approximates predicate locking</li><li>Locks wider range for better performance</li></ul><p>Example: Room booking</p><ul><li>Predicate: ""Room A, 2-4 PM, July 1st""</li><li>Index-range: All Room A or all July 1st slots</li></ul><p><i>(Reference: Predicate locks, p. 259-260; Index-range locks, p. 260-261)</i></p>"
"How does serializable snapshot isolation (SSI) detect and prevent serialization conflicts? What are its performance trade-offs compared to other techniques?";"<p>SSI conflict detection:</p><ul><li>Track transaction reads/writes</li><li>Detect outdated reads at commit time</li><li>Abort transactions if conflicts found</li></ul><p>Performance trade-offs:</p><ul><li>Better than 2PL for read-heavy workloads</li><li>Potential for higher abort rates</li></ul><p><i>(Reference: Serializable Snapshot Isolation (SSI), p. 261-262; Detecting stale MVCC reads, p. 263-264; Performance of serializable snapshot isolation, p. 265)</i></p>"