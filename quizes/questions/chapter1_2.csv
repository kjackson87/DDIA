"What are the three key concerns for data systems discussed in the chapter?";"<p>The three key concerns for data systems discussed in the chapter are:</p><ul><li>Reliability</li><li>Scalability</li><li>Maintainability</li></ul><p><i>(Reference: Page 6)</i></p>"
"How does the book define reliability?";"<p>The book defines reliability as:</p><p>The system should continue to work correctly (performing the correct function at the desired level of performance) even in the face of adversity (hardware or software faults, and even human error).</p><p><i>(Reference: Page 6)</i></p>"
"What is the difference between a fault and a failure?";"<p>The difference between a fault and a failure is:</p><ul><li>A fault is usually defined as one component of the system deviating from its spec</li><li>A failure is when the system as a whole stops providing the required service to the user</li></ul><p><i>(Reference: Page 7)</i></p>"
"What are the three types of faults discussed in the chapter?";"<p>The three types of faults discussed in the chapter are:</p><ul><li>Hardware faults</li><li>Software errors</li><li>Human errors</li></ul><p><i>(Reference: Pages 7-10)</i></p>"
"What is the difference between scaling up and scaling out?";"<p>The difference between scaling up and scaling out is:</p><ul><li>Scaling up (vertical scaling) refers to moving to a more powerful machine</li><li>Scaling out (horizontal scaling) refers to distributing the load across multiple smaller machines</li></ul><p><i>(Reference: Page 17)</i></p>"
"What is tail latency amplification?";"<p>Tail latency amplification is:</p><p>An effect where a small percentage of slow backend calls can cause a higher proportion of end-user requests to be slow, especially when an end-user request requires multiple backend calls.</p><p><i>(Reference: Page 16)</i></p>"
"What are the three design principles for software systems that can help with maintainability?";"<p>The three design principles for software systems that can help with maintainability are:</p><ul><li>Operability</li><li>Simplicity</li><li>Evolvability</li></ul><p><i>(Reference: Page 19)</i></p>"
"How does the book define accidental complexity?";"<p>The book defines accidental complexity as:</p><p>Complexity that is not inherent in the problem that the software solves (as seen by the users) but arises only from the implementation.</p><p><i>(Reference: Page 21)</i></p>"
"What is meant by evolvability in the context of data systems?";"<p>Evolvability in the context of data systems means:</p><p>Making it easy for engineers to make changes to the system in the future, adapting it for unanticipated use cases as requirements change.</p><p><i>(Reference: Page 22)</i></p>"
"What are percentiles used for in measuring response times?";"<p>Percentiles are used for measuring response times to:</p><p>Measure the distribution of response times and understand the experience of typical and outlier requests. For example, the 95th percentile response time means 95% of requests are faster than this time.</p><p><i>(Reference: Pages 14-16)</i></p>"
"What are the three main data models discussed in the chapter?";"<p>The three main data models discussed in the chapter are:</p><ul><li>The relational model</li><li>The document model</li><li>Graph-based data models</li></ul><p><i>(Reference: Page 28)</i></p>"
"What was the main purpose of the relational model when it was introduced?";"<p>The main purpose of the relational model when it was introduced was:</p><p>To hide implementation details behind a cleaner interface and provide a more abstract way of working with data.</p><p><i>(Reference: Page 28)</i></p>"
"What are some of the driving forces behind the adoption of NoSQL databases?";"<p>Some of the driving forces behind the adoption of NoSQL databases are:</p><ul><li>Greater scalability</li><li>Preference for free and open-source software</li><li>Specialized query operations</li><li>Frustration with the restrictiveness of relational schemas</li></ul><p><i>(Reference: Page 29)</i></p>"
"What is the difference between the document data model and the relational model in handling one-to-many relationships?";"<p>The difference between the document data model and the relational model in handling one-to-many relationships is:</p><ul><li>The document model can store nested records (one-to-many relationships) within the parent record</li><li>The relational model typically requires separate tables linked by foreign keys</li></ul><p><i>(Reference: Page 38)</i></p>"
"What is meant by 'schema-on-read' versus 'schema-on-write'?";"<p>The difference between 'schema-on-read' and 'schema-on-write' is:</p><ul><li>Schema-on-read means the structure of the data is implicit and only interpreted when the data is read</li><li>Schema-on-write means the schema is explicit and enforced when data is written to the database</li></ul><p><i>(Reference: Page 40)</i></p>"
"What are the main components of a property graph model?";"<p>The main components of a property graph model are:</p><ul><li>Vertices (with a unique identifier and a set of properties)</li><li>Edges (with a unique identifier, start and end vertices, a label, and a set of properties)</li></ul><p><i>(Reference: Page 50)</i></p>"
"How does a triple-store model differ from a property graph model?";"<p>The difference between a triple-store model and a property graph model is:</p><ul><li>A triple-store model represents all data in the form of (subject, predicate, object) triples</li><li>A property graph model uses separate concepts for vertices and edges with their properties</li></ul><p><i>(Reference: Page 56)</i></p>"
"What is the difference between a declarative query language and an imperative code approach?";"<p>The difference between a declarative query language and an imperative code approach is:</p><ul><li>A declarative query language specifies the pattern of data you want and what conditions the results must meet</li><li>An imperative approach tells the computer exactly how to perform operations to get the desired result</li></ul><p><i>(Reference: Page 43)</i></p>"