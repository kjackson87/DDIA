What are the three main types of faults that can occur in distributed systems?;<p>Three main types of faults:</p><ol><li>Network faults: e.g., packets lost due to switch failure</li><li>Clock faults: e.g., node's clock drifts, causing inconsistent timestamps</li><li>Process pauses: e.g., Java app pauses for garbage collection</li></ol><p><i>(Reference: Faults and Partial Failures, p. 274-275)</i></p>
Why are distributed systems fundamentally different from programs running on a single computer?;<p>Distributed systems differ because:</p><ul><li>No shared memory, only message passing</li><li>Partial failures possible</li><li>Nodes rely on received messages, can't know system state for certain</li></ul><p><i>(Reference: Faults and Partial Failures, p. 274-275)</i></p>
What is the problem with using timeouts to detect failed nodes in a distributed system?;<p>Problems with timeouts:</p><ul><li>Can't distinguish network vs. node failures</li><li>False positives due to network delays (e.g., 6s delay, 5s timeout)</li><li>Miss "limping" nodes (e.g., partial disk failure slowing responses)</li></ul><p><i>(Reference: Unreliable Networks, p. 279-280)</i></p>
What is clock drift and why is it a problem in distributed systems?;<p>Clock drift:</p><ul><li>Clocks run at different speeds (e.g., +10ms/hour)</li><li>Causes desynchronization over time</li><li>Impacts distributed operations and event ordering</li></ul><p><i>(Reference: Clock Synchronization and Accuracy, p. 289-290)</i></p>
What is the danger of relying on timestamps from different nodes to order events in a distributed system?;<p>Dangers of relying on timestamps:</p><ul><li>Clocks often out of sync (e.g., 100ms+ in global systems)</li><li>May violate causality (write with earlier timestamp than a read)</li><li>Can cause errors (e.g., incorrect order in financial trades)</li></ul><p><i>(Reference: Timestamps for ordering events, p. 291-293)</i></p>
What are some reasons why a process might unexpectedly pause for a long time?;<p>Reasons for unexpected pauses:</p><ul><li>Garbage collection</li><li>VM suspension</li><li>OS context switches</li><li>Disk I/O</li><li>Memory swapping</li><li>SIGSTOP signals</li></ul><p><i>(Reference: Process Pauses, p. 295-297)</i></p>
What is the difference between safety and liveness properties in distributed systems?;<p>Safety vs. Liveness:</p><ul><li>Safety: Nothing bad happens (e.g., bank balance never negative)</li><li>Liveness: Good things eventually happen (e.g., Paxos reaches decision)</li><li>Safety must always hold; liveness can have caveats</li></ul><p><i>(Reference: Safety and liveness, p. 308-309)</i></p>
What is the Byzantine Generals Problem?;<p>Byzantine Generals Problem:</p><ul><li>Consensus with arbitrary node failures</li><li>Nodes may send conflicting information</li><li>Models agreeing on state with potential malicious actors</li></ul><p><i>(Reference: Byzantine Faults, p. 304-305)</i></p>
What are the three system models commonly used to reason about distributed algorithms?;<p>Three system models:</p><ol><li>Synchronous: Bounded delays (e.g., real-time aircraft control)</li><li>Partially synchronous: Usually bounded, sometimes not (e.g., typical database)</li><li>Asynchronous: No timing assumptions (e.g., P2P file-sharing)</li></ol><p><i>(Reference: System Model and Reality, p. 306-307)</i></p>
Why is it important to distinguish between node failures and network failures in distributed systems?;<p>Importance of distinguishing failures:</p><ul><li>Often indistinguishable</li><li>Different handling can cause errors</li><li>Algorithms must handle both safely</li></ul><p><i>(Reference: Unreliable Networks, p. 277-279)</i></p>