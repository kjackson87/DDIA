"What are the two main ways data is typically represented in an application?";"<p>The two main ways data is typically represented in an application are:</p><ol><li>In memory, as objects/data structures</li><li>When writing to a file or sending over the network, as a self-contained sequence of bytes</li></ol><p><i>(Reference: Formats for Encoding Data, p. 112)</i></p>"
"What is encoding (in the context of data representation)?"; "<p>Encoding is the translation from in-memory representation to a byte sequence.</p><p><i>(Reference: Formats for Encoding Data, p. 113)</i></p>"
"What are the main problems with language-specific encoding formats?";"<p>The main problems with language-specific encoding formats are:</p><ol><li>Tied to a particular programming language</li><li>Often have security vulnerabilities</li><li>Versioning is often an afterthought</li><li>Efficiency is often poor</li></ol><p><i>(Reference: Formats for Encoding Data - Language-Specific Formats, p. 113-114)</i></p>"
"What are the advantages of using schema-based binary encoding formats like Protocol Buffers, Thrift, or Avro?";"<p>The advantages of using schema-based binary encoding formats like Protocol Buffers, Thrift, or Avro are:</p><ol><li>More compact than JSON and XML</li><li>Schema is a form of documentation</li><li>Schema enables type checking</li><li>Better support for schema evolution</li></ol><p><i>(Reference: Formats for Encoding Data - Thrift and Protocol Buffers, p. 127-128)</i></p>"
"How do Thrift and Protocol Buffers handle schema evolution?";"<p>Thrift and Protocol Buffers handle schema evolution as follows:</p><ol><li>Each field is identified by a tag number</li><li>New fields can be added with new tag numbers</li><li>Old code ignores fields it doesn't recognize</li><li>Field removal is only possible for optional fields</li></ol><p><i>(Reference: Formats for Encoding Data - Thrift and Protocol Buffers, p. 120-121)</i></p>"
"How does Avro handle schema evolution without using tag numbers?";"<p>Avro handles schema evolution without using tag numbers as follows:</p><ol><li>It uses a writer's schema and a reader's schema</li><li>When decoding, Avro resolves differences between the two schemas</li><li>Fields can be added or removed if they have a default value</li></ol><p><i>(Reference: Formats for Encoding Data - Avro, p. 123-124)</i></p>"
"What are the three main modes of dataflow covered in the chapter?";"<p>The three main modes of dataflow covered in the chapter are:</p><ol><li>Databases (process writes, another reads)</li><li>RPC and REST APIs (client encodes request, server decodes and responds)</li><li>Asynchronous message passing (sender encodes, recipient decodes)</li></ol><p><i>(Reference: Modes of Dataflow, p. 129-136)</i></p>"
"What is the difference between backward compatibility and forward compatibility?";"<p>The difference between backward compatibility and forward compatibility is:</p><ul><li>Backward compatibility: Newer code can read data encoded by older code</li><li>Forward compatibility: Older code can read data encoded by newer code</li></ul><p><i>(Reference: Formats for Encoding Data, p. 112)</i></p>"
"What are the main advantages of using a message broker for communication between services?";"<p>The main advantages of using a message broker for communication between services are:</p><ol><li>Acts as a buffer if recipient is unavailable</li><li>Can automatically redeliver messages</li><li>Avoids sender needing to know IP/port of recipient</li><li>Allows one message to be sent to multiple recipients</li><li>Logically decouples sender from recipient</li></ol><p><i>(Reference: Modes of Dataflow - Message-Passing Dataflow, p. 137)</i></p>"
"What is the key idea behind the actor model for concurrency?";"<p>The key idea behind the actor model for concurrency is:</p><p>Logic is encapsulated in actors, which communicate through asynchronous message passing, avoiding shared state and the complexities of traditional multithreading</p><p><i>(Reference: Modes of Dataflow - Distributed actor frameworks, p. 138)</i></p>"